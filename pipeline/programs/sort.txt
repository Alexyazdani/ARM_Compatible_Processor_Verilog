
0   mov   r12, #0         // Init “i” to zero
1   nop
2   nop
3   nop
4   b     .LBB0_2         // Branch to label
.LBB0_1:
5   cmp   r12, #9         // Compare “i” and value 9
6   nop
7   beq   .LBB0_5         // Branch to label (END), if equal (i==9)
.LBB0_2:
8   mov   r2, r12         // Save R12 (current, “i”) into R2
9   nop
10  nop
11  nop
12  add   r12, r12, #1    // i++
13  cmp   r2, #7          // Compare R2 and value 7
14  nop
15  bhi   .LBB0_1         // Branch to label, if unsigned higher
16  mov   r3, r2          // Update “j” (next) with “i” (current)
17  nop
18  nop
19  nop
.LBB0_4:
20  add   r9, r3, #1      // Used as offset into next index
21  nop 
22  nop
23  nop
24  ldr   r5, r9          // Load R5 with R3+1 (next index)
25  ldr   r4, r2          // Load R4 with R2+0 (current index)
26  nop
27  nop
28  nop
29  cmp   r5, r4          // Compare next and current (used for SWAP)
30  nop
31  strlt r4, r9          // Store R4 into R3+1, if R5 < R4 (signed)
32  strlt r5, r2          // Store R5 into R2+0, if R5 < R4 (signed)
33  add   r3, r3, #1      // j++
34  cmp   r3, #8          // Compare “j” with value 8
35  nop
36  bne   .LBB0_4         // Branch to label, if not equal (j!=8)
37  b     .LBB0_1         // Branch to label
.LBB0_5:                  // PROGRAM END
38  nop
///////////////////////////////////////////////////////////////////////////////////////
//
// PROGRAM BINARY W/ FIELD SEPARATIONS FOR DEBUG
Cond    I OpCo S Rn   Rd   Op2
1110 00 1 1101 0 0000 1100 000000000000 // mov r12, #0 : MOV (imm), ignores Rn
11101100000000000000000000000000 // nops
11101100000000000000000000000000
11101100000000000000000000000000

Cond     L Offset
1110 101 0 000000000000000000001000 // b .LBB0_2 : Branch to inst. 8

Cond    I OpCo S Rn   Rd   Op2
1110 00 1 1010 1 1100 0000 000000001001 // cmp r12, #9 : CMP (imm) R12 and #9
11101100000000000000000000000000

Cond     L Offset
0000 101 0 000000000000000000100110 // beq .LBB0_5 : Branch EQ to inst. 38

Cond    I OpCo S Rn   Rd   Op2
1110 00 0 1101 0 0000 0000 000000000000 // mov r2, r12 : MOV (reg), ignores Rn
11101100000000000000000000000000
11101100000000000000000000000000
11101100000000000000000000000000

1110 00 1 0100 0 1100 1100 000000000001 // add r12, r12, #1 : ADD (imm) R12 = R12 + 1
1110 00 1 1010 1 1100 0000 000000000111 // cmp r2, #7 : CMP (imm) R2 and #7
11101100000000000000000000000000

Cond     L Offset
1000 101 0 000000000000000000000101 // bhi .LBB0_1 : Branch HI to inst. 5

Cond    I OpCo S Rn   Rd   Op2      Rm
1110 00 0 1101 0 0000 0011 00000000 0010 // mov r3, r2 : MOV (reg), ignores Rn, uses Rm
11101100000000000000000000000000
11101100000000000000000000000000
11101100000000000000000000000000

Cond    I OpCo S Rn   Rd   Op2      Rm
1110 00 1 0100 0 0011 1001 000000000001 // add r9, r3, #1 : ADD (imm) R9 = R3 + 1
11101100000000000000000000000000
11101100000000000000000000000000
11101100000000000000000000000000

Cond    I P U B W L Rn   Rd   Shift    Rm
1110 01 0 0 0 0 0 1 1001 0101 00000000 0000 // ldr r5, r9 : LDR (reg) R5 = addr(R9)
1110 01 0 0 0 0 0 1 0010 0100 00000000 0000 // ldr r4, r2 : LDR (reg) R4 = addr(R2)
11101100000000000000000000000000
11101100000000000000000000000000
11101100000000000000000000000000

Cond    I OpCo S Rn   Rd   Op2      Rm
1110 00 0 1010 1 0101 0000 00000000 0100 // cmp r5, r4 : CMP (reg)
11101100000000000000000000000000

Cond    I P U B W L Rn   Rd   Shift    Rm
1011 01 0 0 0 0 0 0 0001 0000 00000000 0101 // strlt r5, r9 : STRLT (reg) addr(R9) = R5
1011 01 0 0 0 0 0 0 0000 0000 00000000 0100 // strlt r4, r2 : STRLT (reg) addr(R2) = R4

Cond    I OpCo S Rn   Rd   Op2
1110 00 1 0100 0 0011 0011 000000000001 // add r3, r3, #1 : ADD (imm) R3 = R3 + 1

Cond    I OpCo S Rn   Rd   Op2
1110 00 1 1010 1 1100 0000 000000001000 // cmp r3, #8 : CMP (imm) R3 and #8
11101100000000000000000000000000

Cond     L Offset
0001 101 0 000000000000000000010100 // bne .LBB0_4 : Branch NE to inst. 20

Cond     L Offset
1110 101 0 000000000000000000000101 // b .LBB0_1 : Branch to inst. 5

////////////////////////////////
//
// RAW BINARY (32-bit)
// IMEM:
11100011101000001100000000000000
11101100000000000000000000000000
11101100000000000000000000000000
11101100000000000000000000000000
11101010000000000000000000001000
11100011010111000000000000001001
11101100000000000000000000000000
00001010000000000000000000100110
11100001101000000000000000000000
11101100000000000000000000000000
11101100000000000000000000000000
11101100000000000000000000000000
11100010100011001100000000000001
11100011010111000000000000000111
11101100000000000000000000000000
10001010000000000000000000000101
11100001101000000011000000000010
11101100000000000000000000000000
11101100000000000000000000000000
11101100000000000000000000000000
11100010100000111001000000000001
11101100000000000000000000000000
11101100000000000000000000000000
11101100000000000000000000000000
10110100000000010000000000000101
10110100000000000000000000000100
11101100000000000000000000000000
11101100000000000000000000000000
11101100000000000000000000000000
11100001010101010000000000000100
11101100000000000000000000000000
10110100000000010101000000000000
10110100000000000100000000000000
11100010100000110011000000000001
11100011010111000000000000001000
11101100000000000000000000000000
00011010000000000000000000010100
11101010000000000000000000000101
11101100000000000000000000000000

// DMEM (MUST BE 10 VALUES):
00000000000000000000000000001001
00000000000000000000000000000100
00000000000000000000000000000101
00000000000000000000000000000010
00000000000000000000000000000000
00000000000000000000000000000110
00000000000000000000000000000011
00000000000000000000000000000111
00000000000000000000000000000001
00000000000000000000000000001000
